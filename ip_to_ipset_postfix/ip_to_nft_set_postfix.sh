#!/bin/bash
#
# This is a rather minimal example Argbash potential
# Example taken from http://argbash.readthedocs.io/en/stable/example.html
#
# ARG_OPTIONAL_SINGLE([log-file-fullpath],[l],[Full Path To Postfix Log File],[/var/log/mail/mail-nft-set.log])
# ARG_OPTIONAL_SINGLE([nft-table-family],[f],[NFT Table Family],[inet])
# ARG_OPTIONAL_SINGLE([nft-table-name],[n],[NFT Table Name],[table_filter])
# ARG_OPTIONAL_SINGLE([nft-set-name],[s],[NFT Set Name],[blackhole])
# ARG_OPTIONAL_SINGLE([nft-set-timeout],[t],[How long (in seconds) ip address will be in nft set],[3600])
# ARG_OPTIONAL_SINGLE([attempts],[a],[How Many Attempts are Allowed],[20])
# ARG_OPTIONAL_SINGLE([script-log],[],[Full Path To This Script Log File],[/var/log/mail/ip_to_nft_set_postfix.log])
# ARG_OPTIONAL_BOOLEAN([clear-postfix-log-file],[c],[on/off - clear postfix log file],[off])

# ARG_HELP([The general script's help msg])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.9.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate


# # When called, the process ends.
# Args:
#       $1: The exit message (print to stderr)
#       $2: The exit code (default is 1)
# if env var _PRINT_HELP is set to 'yes', the usage is print to stderr (prior to $1)
# Example:
#       test -f "$_arg_infile" || _PRINT_HELP=yes die "Can't continue, have to supply file as an argument, got '$_arg_infile'" 4
die()
{
        local _ret="${2:-1}"
        test "${_PRINT_HELP:-no}" = yes && print_help >&2
        echo "$1" >&2
        exit "${_ret}"
}


# Function that evaluates whether a value passed to it begins by a character
# that is a short option of an argument the script knows about.
# This is required in order to support getopts-like short options grouping.
begins_with_short_option()
{
        local first_option all_short_options='lfnstach'
        first_option="${1:0:1}"
        test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_log_file_fullpath="/var/log/mail/mail-nft-set.log"
_arg_nft_table_family="inet"
_arg_nft_table_name="table_filter"
_arg_nft_set_name="blackhole"
_arg_nft_set_timeout="3600"
_arg_attempts="20"
_arg_script_log="/var/log/mail/ip_to_nft_set_postfix.log"
_arg_clear_postfix_log_file="off"


# Function that prints general usage of the script.
# This is useful if users asks for it, or if there is an argument parsing error (unexpected / spurious arguments)
# and it makes sense to remind the user how the script is supposed to be called.
print_help()
{
        printf '%s\n' "The general script's help msg"
        printf 'Usage: %s [-l|--log-file-fullpath <arg>] [-f|--nft-table-family <arg>] [-n|--nft-table-name <arg>] [-s|--nft-set-name <arg>] [-t|--nft-set-timeout <arg>] [-a|--attempts <arg>] [--script-log <arg>] [-c|--(no-)clear-postfix-log-file] [-h|--help]\n' "$0"
        printf '\t%s\n' "-l, --log-file-fullpath: Full Path To Postfix Log File (default: '/var/log/mail/mail-nft-set.log')"
        printf '\t%s\n' "-f, --nft-table-family: NFT Table Family (default: 'inet')"
        printf '\t%s\n' "-n, --nft-table-name: NFT Table Name (default: 'table_filter')"
        printf '\t%s\n' "-s, --nft-set-name: NFT Set Name (default: 'blackhole')"
        printf '\t%s\n' "-t, --nft-set-timeout: How long (in seconds) ip address will be in nft set (default: '3600')"
        printf '\t%s\n' "-a, --attempts: How Many Attempts are Allowed (default: '20')"
        printf '\t%s\n' "--script-log: Full Path To This Script Log File (default: '/var/log/mail/ip_to_nft_set_postfix.log')"
        printf '\t%s\n' "-c, --clear-postfix-log-file, --no-clear-postfix-log-file: on/off - clear postfix log file (off by default)"
        printf '\t%s\n' "-h, --help: Prints help"
}


# The parsing of the command-line
parse_commandline()
{
        while test $# -gt 0
        do
                _key="$1"
                case "$_key" in
                        # We support whitespace as a delimiter between option argument and its value.
                        # Therefore, we expect the --log-file-fullpath or -l value.
                        # so we watch for --log-file-fullpath and -l.
                        # Since we know that we got the long or short option,
                        # we just reach out for the next argument to get the value.
                        -l|--log-file-fullpath)
                                test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
                                _arg_log_file_fullpath="$2"
                                shift
                                ;;
                        # We support the = as a delimiter between option argument and its value.
                        # Therefore, we expect --log-file-fullpath=value, so we watch for --log-file-fullpath=*
                        # For whatever we get, we strip '--log-file-fullpath=' using the ${var##--log-file-fullpath=} notation
                        # to get the argument value
                        --log-file-fullpath=*)
                                _arg_log_file_fullpath="${_key##--log-file-fullpath=}"
                                ;;
                        # We support getopts-style short arguments grouping,
                        # so as -l accepts value, we allow it to be appended to it, so we watch for -l*
                        # and we strip the leading -l from the argument string using the ${var##-l} notation.
                        -l*)
                                _arg_log_file_fullpath="${_key##-l}"
                                ;;
                        # See the comment of option '--log-file-fullpath' to see what's going on here - principle is the same.
                        -f|--nft-table-family)
                                test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
                                _arg_nft_table_family="$2"
                                shift
                                ;;
                        # See the comment of option '--log-file-fullpath=' to see what's going on here - principle is the same.
                        --nft-table-family=*)
                                _arg_nft_table_family="${_key##--nft-table-family=}"
                                ;;
                        # See the comment of option '-l' to see what's going on here - principle is the same.
                        -f*)
                                _arg_nft_table_family="${_key##-f}"
                                ;;
                        # See the comment of option '--log-file-fullpath' to see what's going on here - principle is the same.
                        -n|--nft-table-name)
                                test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
                                _arg_nft_table_name="$2"
                                shift
                                ;;
                        # See the comment of option '--log-file-fullpath=' to see what's going on here - principle is the same.
                        --nft-table-name=*)
                                _arg_nft_table_name="${_key##--nft-table-name=}"
                                ;;
                        # See the comment of option '-l' to see what's going on here - principle is the same.
                        -n*)
                                _arg_nft_table_name="${_key##-n}"
                                ;;
                        # See the comment of option '--log-file-fullpath' to see what's going on here - principle is the same.
                        -s|--nft-set-name)
                                test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
                                _arg_nft_set_name="$2"
                                shift
                                ;;
                        # See the comment of option '--log-file-fullpath=' to see what's going on here - principle is the same.
                        --nft-set-name=*)
                                _arg_nft_set_name="${_key##--nft-set-name=}"
                                ;;
                        # See the comment of option '-l' to see what's going on here - principle is the same.
                        -s*)
                                _arg_nft_set_name="${_key##-s}"
                                ;;
                        # See the comment of option '--log-file-fullpath' to see what's going on here - principle is the same.
                        -t|--nft-set-timeout)
                                test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
                                _arg_nft_set_timeout="$2"
                                shift
                                ;;
                        # See the comment of option '--log-file-fullpath=' to see what's going on here - principle is the same.
                        --nft-set-timeout=*)
                                _arg_nft_set_timeout="${_key##--nft-set-timeout=}"
                                ;;
                        # See the comment of option '-l' to see what's going on here - principle is the same.
                        -t*)
                                _arg_nft_set_timeout="${_key##-t}"
                                ;;
                        # See the comment of option '--log-file-fullpath' to see what's going on here - principle is the same.
                        -a|--attempts)
                                test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
                                _arg_attempts="$2"
                                shift
                                ;;
                        # See the comment of option '--log-file-fullpath=' to see what's going on here - principle is the same.
                        --attempts=*)
                                _arg_attempts="${_key##--attempts=}"
                                ;;
                        # See the comment of option '-l' to see what's going on here - principle is the same.
                        -a*)
                                _arg_attempts="${_key##-a}"
                                ;;
                        # See the comment of option '--log-file-fullpath' to see what's going on here - principle is the same.
                        --script-log)
                                test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
                                _arg_script_log="$2"
                                shift
                                ;;
                        # See the comment of option '--log-file-fullpath=' to see what's going on here - principle is the same.
                        --script-log=*)
                                _arg_script_log="${_key##--script-log=}"
                                ;;
                        # The clear-postfix-log-file argurment doesn't accept a value,
                        # we expect the --clear-postfix-log-file or -c, so we watch for them.
                        -c|--no-clear-postfix-log-file|--clear-postfix-log-file)
                                _arg_clear_postfix_log_file="on"
                                test "${1:0:5}" = "--no-" && _arg_clear_postfix_log_file="off"
                                ;;
                        # We support getopts-style short arguments clustering,
                        # so as -c doesn't accept value, other short options may be appended to it, so we watch for -c*.
                        # After stripping the leading -c from the argument, we have to make sure
                        # that the first character that follows coresponds to a short option.
                        -c*)
                                _arg_clear_postfix_log_file="on"
                                _next="${_key##-c}"
                                if test -n "$_next" -a "$_next" != "$_key"
                                then
                                        { begins_with_short_option "$_next" && shift && set -- "-c" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
                                fi
                                ;;
                        # See the comment of option '--clear-postfix-log-file' to see what's going on here - principle is the same.
                        -h|--help)
                                print_help
                                exit 0
                                ;;
                        # See the comment of option '-c' to see what's going on here - principle is the same.
                        -h*)
                                print_help
                                exit 0
                                ;;
                        *)
                                _PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
                                ;;
                esac
                shift
        done
}

# Now call all the functions defined above that are needed to get the job done
parse_commandline "$@"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

# ] <-- needed because of Argbash




# Start my script

# Array of whitelisted ip addresses
ip_whitelist=("84.244.68.207" "217.16.180.55" "77.236.196.7")

echo "`date`    ############ SCRIPT BEGIN ############" >> $_arg_script_log


# get bad ip addresses from postfix mail log
ip_addresses=`cat $_arg_log_file_fullpath | grep 'SASL LOGIN authentication failed: generic failure' | grep failure | awk '{match($0,/[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/); ip = substr($0,RSTART,RLENGTH); print ip}' | sed '/^\s*$/d' | sort | uniq -c | sort -n -r | awk -v ref="$_arg_attempts" '{ if ($1 >= ref) print $2 }'`

# split string into array
ip_addresses=($ip_addresses)

# remove whitelisted ip addressess from bad ip addressess array
for index in "${!ip_addresses[@]}"; do
    for del in "${ip_whitelist[@]}"; do
        if [[ ${ip_addresses[$index]} == $del ]]; then
            unset 'ip_addresses[index]'
        fi
    done
done

# zapisu najdene ip adresy do logu
echo "`date`    Found this ip addressess: ${ip_addresses[*]}" >> $_arg_script_log

# add ip address to given nft set
# nastavim string  _arg_nft_set_timeouts tak,aby na konci mel pismeno "s"
_arg_nft_set_timeout+="s"
for item in "${ip_addresses[@]}"
do
    nft get element $_arg_nft_table_family $_arg_nft_table_name $_arg_nft_set_name { $item } 2>&1 | sed -e "s/^/$(date)    /" >> $_arg_script_log
    if [ ${PIPESTATUS[0]} -eq 0 ]
    then
        echo "`date`    skip $item: ip address $item found in nft set $_arg_nft_set_name" >> $_arg_script_log
    else
        echo "`date`    add $item because ip address $item not found in nft set $_arg_nft_set_name" >> $_arg_script_log
        nft add element $_arg_nft_table_family $_arg_nft_table_name $_arg_nft_set_name { $item timeout $_arg_nft_set_timeout } >> $_arg_script_log
    fi
done


# clear log
if [ $_arg_clear_postfix_log_file != "off" ] 
then
    cat /dev/null > $_arg_log_file_fullpath
    echo "`date`    Log File $_arg_log_file_fullpath was cleared" >> $_arg_script_log 
fi
