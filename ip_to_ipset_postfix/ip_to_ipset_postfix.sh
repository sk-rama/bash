#!/bin/bash
version="0.7"
#
# This is an optional arguments-only example of Argbash potential
#
# ARG_OPTIONAL_SINGLE([log-file-fullpath],[l],[Full Path To Postfix Log File],[/var/log/mail/mail-ipset.log])
# ARG_OPTIONAL_SINGLE([ipset-name],[n],[IPSET Name],[postfix])
# ARG_OPTIONAL_SINGLE([ipset-timeout],[i],[Default timeout (in seconds) for created ipset - default 49 days],[4294967])
# ARG_OPTIONAL_SINGLE([timeout],[t],[How long (in seconds) ip address will be in ipset],[3600])
# ARG_OPTIONAL_SINGLE([attempts],[a],[How Many Attempts are Allowed],[20])
# ARG_OPTIONAL_SINGLE([script-log],[s],[Full Path To This Script Log File],[/var/log/mail/ip_to_ipset_postfix.log])
# ARG_OPTIONAL_BOOLEAN([clear-postfix-log-file],[c],[on/off - clear postfix log file],[off])

# ARG_VERSION([echo ip_to_ipset_postfix.sh v$version])
# ARG_HELP([The general script's help msg])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.9.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate


# # When called, the process ends.
# Args:
#       $1: The exit message (print to stderr)
#       $2: The exit code (default is 1)
# if env var _PRINT_HELP is set to 'yes', the usage is print to stderr (prior to $1)
# Example:
#       test -f "$_arg_infile" || _PRINT_HELP=yes die "Can't continue, have to supply file as an argument, got '$_arg_infile'" 4
die()
{
        local _ret="${2:-1}"
        test "${_PRINT_HELP:-no}" = yes && print_help >&2
        echo "$1" >&2
        exit "${_ret}"
}


# Function that evaluates whether a value passed to it begins by a character
# that is a short option of an argument the script knows about.
# This is required in order to support getopts-like short options grouping.
begins_with_short_option()
{
        local first_option all_short_options='lnitascvh'
        first_option="${1:0:1}"
        test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_log_file_fullpath="/var/log/mail/mail-ipset.log"
_arg_ipset_name="postfix"
_arg_ipset_timeout="4294967"
_arg_timeout="3600"
_arg_attempts="20"
_arg_script_log="/var/log/mail/ip_to_ipset_postfix.log"
_arg_clear_postfix_log_file="off"


# Function that prints general usage of the script.
# This is useful if users asks for it, or if there is an argument parsing error (unexpected / spurious arguments)
# and it makes sense to remind the user how the script is supposed to be called.
print_help()
{
        printf '%s\n' "The general script's help msg"
        printf 'Usage: %s [-l|--log-file-fullpath <arg>] [-n|--ipset-name <arg>] [-i|--ipset-timeout <arg>] [-t|--timeout <arg>] [-a|--attempts <arg>] [-s|--script-log <arg>] [-c|--(no-)clear-postfix-log-file] [-v|--version] [-h|--help]\n' "$0"
        printf '\t%s\n' "-l, --log-file-fullpath: Full Path To Postfix Log File (default: '/var/log/mail/mail-ipset.log')"
        printf '\t%s\n' "-n, --ipset-name: IPSET Name (default: 'postfix')"
        printf '\t%s\n' "-i, --ipset-timeout: Default timeout (in seconds) for created ipset - default 49 days (default: '4294967')"
        printf '\t%s\n' "-t, --timeout: How long (in seconds) ip address will be in ipset (default: '3600')"
        printf '\t%s\n' "-a, --attempts: How Many Attempts are Allowed (default: '20')"
        printf '\t%s\n' "-s, --script-log: Full Path To This Script Log File (default: '/var/log/mail/ip_to_ipset_postfix.log')"
        printf '\t%s\n' "-c, --clear-postfix-log-file, --no-clear-postfix-log-file: on/off - clear postfix log file (off by default)"
        printf '\t%s\n' "-v, --version: Prints version"
        printf '\t%s\n' "-h, --help: Prints help"
}


# The parsing of the command-line
parse_commandline()
{
        while test $# -gt 0
        do
                _key="$1"
                case "$_key" in
                        # We support whitespace as a delimiter between option argument and its value.
                        # Therefore, we expect the --log-file-fullpath or -l value.
                        # so we watch for --log-file-fullpath and -l.
                        # Since we know that we got the long or short option,
                        # we just reach out for the next argument to get the value.
                        -l|--log-file-fullpath)
                                test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
                                _arg_log_file_fullpath="$2"
                                shift
                                ;;
                        # We support the = as a delimiter between option argument and its value.
                        # Therefore, we expect --log-file-fullpath=value, so we watch for --log-file-fullpath=*
                        # For whatever we get, we strip '--log-file-fullpath=' using the ${var##--log-file-fullpath=} notation
                        # to get the argument value
                        --log-file-fullpath=*)
                                _arg_log_file_fullpath="${_key##--log-file-fullpath=}"
                                ;;
                        # We support getopts-style short arguments grouping,
                        # so as -l accepts value, we allow it to be appended to it, so we watch for -l*
                        # and we strip the leading -l from the argument string using the ${var##-l} notation.
                        -l*)
                                _arg_log_file_fullpath="${_key##-l}"
                                ;;
                        # See the comment of option '--log-file-fullpath' to see what's going on here - principle is the same.
                        -n|--ipset-name)
                                test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
                                _arg_ipset_name="$2"
                                shift
                                ;;
                        # See the comment of option '--log-file-fullpath=' to see what's going on here - principle is the same.
                        --ipset-name=*)
                                _arg_ipset_name="${_key##--ipset-name=}"
                                ;;
                        # See the comment of option '-l' to see what's going on here - principle is the same.
                        -n*)
                                _arg_ipset_name="${_key##-n}"
                                ;;
                        # See the comment of option '--log-file-fullpath' to see what's going on here - principle is the same.
                        -i|--ipset-timeout)
                                test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
                                _arg_ipset_timeout="$2"
                                shift
                                ;;
                        # See the comment of option '--log-file-fullpath=' to see what's going on here - principle is the same.
                        --ipset-timeout=*)
                                _arg_ipset_timeout="${_key##--ipset-timeout=}"
                                ;;
                        # See the comment of option '-l' to see what's going on here - principle is the same.
                        -i*)
                                _arg_ipset_timeout="${_key##-i}"
                                ;;
                        # See the comment of option '--log-file-fullpath' to see what's going on here - principle is the same.
                        -t|--timeout)
                                test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
                                _arg_timeout="$2"
                                shift
                                ;;
                        # See the comment of option '--log-file-fullpath=' to see what's going on here - principle is the same.
                        --timeout=*)
                                _arg_timeout="${_key##--timeout=}"
                                ;;
                        # See the comment of option '-l' to see what's going on here - principle is the same.
                        -t*)
                                _arg_timeout="${_key##-t}"
                                ;;
                        # See the comment of option '--log-file-fullpath' to see what's going on here - principle is the same.
                        -a|--attempts)
                                test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
                                _arg_attempts="$2"
                                shift
                                ;;
                        # See the comment of option '--log-file-fullpath=' to see what's going on here - principle is the same.
                        --attempts=*)
                                _arg_attempts="${_key##--attempts=}"
                                ;;
                        # See the comment of option '-l' to see what's going on here - principle is the same.
                        -a*)
                                _arg_attempts="${_key##-a}"
                                ;;
                        # See the comment of option '--log-file-fullpath' to see what's going on here - principle is the same.
                        -s|--script-log)
                                test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
                                _arg_script_log="$2"
                                shift
                                ;;
                        # See the comment of option '--log-file-fullpath=' to see what's going on here - principle is the same.
                        --script-log=*)
                                _arg_script_log="${_key##--script-log=}"
                                ;;
                        # See the comment of option '-l' to see what's going on here - principle is the same.
                        -s*)
                                _arg_script_log="${_key##-s}"
                                ;;
                        # The clear-postfix-log-file argurment doesn't accept a value,
                        # we expect the --clear-postfix-log-file or -c, so we watch for them.
                        -c|--no-clear-postfix-log-file|--clear-postfix-log-file)
                                _arg_clear_postfix_log_file="on"
                                test "${1:0:5}" = "--no-" && _arg_clear_postfix_log_file="off"
                                ;;
                        # We support getopts-style short arguments clustering,
                        # so as -c doesn't accept value, other short options may be appended to it, so we watch for -c*.
                        # After stripping the leading -c from the argument, we have to make sure
                        # that the first character that follows coresponds to a short option.
                        -c*)
                                _arg_clear_postfix_log_file="on"
                                _next="${_key##-c}"
                                if test -n "$_next" -a "$_next" != "$_key"
                                then
                                        { begins_with_short_option "$_next" && shift && set -- "-c" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
                                fi
                                ;;
                        # See the comment of option '--clear-postfix-log-file' to see what's going on here - principle is the same.
                        -v|--version)
                                echo ip_to_ipset_postfix.sh v$version
                                exit 0
                                ;;
                        # See the comment of option '-c' to see what's going on here - principle is the same.
                        -v*)
                                echo ip_to_ipset_postfix.sh v$version
                                exit 0
                                ;;
                        # See the comment of option '--clear-postfix-log-file' to see what's going on here - principle is the same.
                        -h|--help)
                                print_help
                                exit 0
                                ;;
                        # See the comment of option '-c' to see what's going on here - principle is the same.
                        -h*)
                                print_help
                                exit 0
                                ;;
                        *)
                                _PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
                                ;;
                esac
                shift
        done
}

# Now call all the functions defined above that are needed to get the job done
parse_commandline "$@"


# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


echo "Value of --log-file-fullpath: $_arg_log_file_fullpath"
echo "Value of --ipset-name: $_arg_ipset_name"
echo "Value of --ipset-timeout: $_arg_ipset_timeout"
echo "Value of --timeout: $_arg_timeout"
echo "Value of --attempts: $_arg_attempts"
echo "Value of --script-log: $_arg_script_log"
echo "Value of --clear-postfix-log-file: $_arg_clear_postfix_log_file"

# ] <-- needed because of Argbash





echo "`date`    ############ SCRIPT BEGIN ############" >> $_arg_script_log

# test that ipset with given name exist
if [ `ipset list | grep "Name: $_arg_ipset_name" | wc -l` -eq 0 ]
then
    # Create the new ipset set
    echo "`date`    ipset with name $_arg_ipset_name doesn't exist, create one" >> $_arg_script_log
    ipset create $_arg_ipset_name hash:ip maxelem 16777216 timeout $_arg_ipset_timeout >>$_arg_script_log 2>&1
    echo "`date`    ipset with name $_arg_ipset_name was created" >> $_arg_script_log
else
    echo "`date`    ipset with name $_arg_ipset_name exist" >> $_arg_script_log
fi

# get bad ip addresses from postfix mail log
ip_addresses=`cat $_arg_log_file_fullpath | grep SASL | grep failure | awk '{match($0,/[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/); ip = substr($0,RSTART,RLENGTH); print ip}' | sed '/^\s*$/d' | sort | uniq -c | sort -n -r | awk -v ref="$_arg_attempts" '{ if ($1 >= ref) print $2 }'`


# add ip address to given ipset
for item in $ip_addresses
do
    ipset test $_arg_ipset_name $item 2>&1 | sed -e "s/^/$(date)    /" >> $_arg_script_log
    if [ ${PIPESTATUS[0]} -eq 0 ]
    then
        echo "`date`    skip $item: ip address $item found in ipset $_arg_ipset_name" >> $_arg_script_log
    else
        echo "`date`    add $item because ip address $item not found in ipset $_arg_ipset_name" >> $_arg_script_log
        ipset add $_arg_ipset_name $item timeout $_arg_timeout 2>&1 | sed -e "s/^/$(date)    /" >> $_arg_script_log
    fi
done


# clear log
if [ $_arg_clear_postfix_log_file != "off" ] 
then
    cat /dev/null > $_arg_log_file_fullpath
    echo "`date`    Log File $_arg_log_file_fullpath was cleared" >> $_arg_script_log
fi
